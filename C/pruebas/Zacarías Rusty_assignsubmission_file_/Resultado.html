compila correctamente<br>
<html>
<body>
  <p>Calificación final: 7/10<br></p>
  <table border="1">
    <tr>
      <th>Método</th>
      <th>Puntuación</th>
      <th>Retroalimentación</th>
    </tr>
    <tr>
      <td>poly_crear</td>
      <td>0.5 / 1</td>
      <td>
        <strong>Funcionalidad:</strong> La función reserva memoria y asigna correctamente los punteros <code>primero</code> y <code>ultimo</code>, pero finaliza el programa con <code>exit(1)</code> en lugar de <code>exit(-1)</code> como se especifica.<br>
        <strong>Mantenimiento:</strong> El uso de <code>*p</code> es adecuado, aunque se puede mejorar la documentación interna para futuros cambios.<br>
        <strong>Claridad:</strong> La función es corta y fácil de leer, pero se podría mejorar el mensaje de error y utilizar el código de salida correcto para mayor coherencia.<br>
        <strong>Eficiencia:</strong> No se identifican ineficiencias en esta función.<br>
        <em>Sugerencia Formativa:</em> Asegúrate de usar el código de salida especificado (<code>-1</code>) y considera agregar comentarios breves sobre la inicialización de la estructura.
      </td>
    </tr>
    <tr>
      <td>poly_grado</td>
      <td>1 / 1</td>
      <td>
        <strong>Funcionalidad:</strong> La función obtiene el grado del polinomio utilizando el puntero al último nodo, lo cual es correcto y eficiente. Devuelve -1 cuando el polinomio es NULL o está vacío.<br>
        <strong>Mantenimiento:</strong> La estructura es sencilla y se pueden reutilizar patrones en otras funciones si se necesitara.<br>
        <strong>Claridad:</strong> El uso de la variable <code>res</code> es claro, aunque se podría renombrarla a <code>grado</code> para mejorar la legibilidad.<br>
        <strong>Eficiencia:</strong> Al usar el puntero <code>ultimo</code>, la función opera en O(1), lo que es óptimo.<br>
        <em>Sugerencia Formativa:</em> Considera mejorar los nombres de las variables para reflejar su propósito.
      </td>
    </tr>
    <tr>
      <td>poly_coeficiente</td>
      <td>1 / 1</td>
      <td>
        <strong>Funcionalidad:</strong> La función recorre la lista de monomios hasta encontrar el exponente solicitado y devuelve el coeficiente correspondiente o 0 si no existe. Se valida que el exponente sea no negativo.<br>
        <strong>Mantenimiento:</strong> La estructura es correcta y podría beneficiarse de una función auxiliar para búsquedas, si se repite la lógica en otras funciones.<br>
        <strong>Claridad:</strong> Los nombres de variables son aceptables, aunque podrían ser más descriptivos (por ejemplo, <code>aux</code> podría llamarse <code>actual</code>).<br>
        <strong>Eficiencia:</strong> El recorrido se detiene tan pronto como se pasa el exponente buscado, lo que es satisfactorio.<br>
        <em>Sugerencia Formativa:</em> Revisa siempre la consistencia en el manejo de casos límite, como exponente negativo, y considera documentar la lógica del recorrido.
      </td>
    </tr>
    <tr>
      <td>poly_agregar</td>
      <td>1.0 / 2.5</td>
      <td>
        <strong>Funcionalidad:</strong> La función intenta insertar un monomio ordenado y sumar coeficientes en caso de repetición, pero presenta un problema crítico: cuando se debe insertar al principio (o se encuentra un monomio con el mismo exponente en la cabeza), la variable <code>previo</code> no se inicializa, lo que puede causar un comportamiento inesperado al llamar a <code>sumarMonomiosF</code>. Además, aunque se actualiza el puntero <code>ultimo</code> al insertar al final, la lógica de actualización en otros casos es frágil.<br>
        <strong>Mantenimiento:</strong> La función es algo extensa y se beneficiaría de descomponer partes en funciones auxiliares (por ejemplo, para la inserción en cabeza versus intermedia o final).<br>
        <strong>Claridad:</strong> La mezcla de punteros dobles y la falta de inicialización clara de variables locales (como <code>previo</code>) dificulta la comprensión y el mantenimiento.<br>
        <strong>Eficiencia:</strong> El recorrido de la lista es correcto, pero se podría optimizar la suma de coeficientes si se combinan algunas comprobaciones.<br>
        <em>Sugerencia Formativa:</em> Reestructura la función separando la búsqueda del punto de inserción en una función auxiliar y asegúrate de inicializar todas las variables antes de usarlas, especialmente al tratar con la cabeza de la lista.
      </td>
    </tr>
    <tr>
      <td>poly_imprimir</td>
      <td>1.25 / 1.25</td>
      <td>
        <strong>Funcionalidad:</strong> Imprime correctamente cada monomio en el formato esperado y maneja el caso de un polinomio inexistente mostrando el mensaje adecuado.<br>
        <strong>Mantenimiento:</strong> La función está bien estructurada y modularizada al delegar la impresión de cada monomio a <code>imprimirMonomio</code>.<br>
        <strong>Claridad:</strong> El código es fácil de entender y sigue un flujo lineal sin complejidades innecesarias.<br>
        <strong>Eficiencia:</strong> Opera de forma directa, sin recorrer la lista más de una vez.<br>
        <em>Sugerencia Formativa:</em> Se sugiere mantener este nivel de claridad y modularidad en otras funciones.
      </td>
    </tr>
    <tr>
      <td>poly_destruir</td>
      <td>1.25 / 1.25</td>
      <td>
        <strong>Funcionalidad:</strong> Libera correctamente todos los nodos del polinomio y restaura los punteros <code>primero</code> y <code>ultimo</code> a <code>NULL</code>, previniendo fugas de memoria.<br>
        <strong>Mantenimiento:</strong> La función sigue un patrón de iteración simple y es fácil de reutilizar o modificar si se cambia la estructura.<br>
        <strong>Claridad:</strong> La nomenclatura de las variables y la secuencia de operaciones son intuitivas.<br>
        <strong>Eficiencia:</strong> Libera la memoria de cada nodo de manera óptima.<br>
        <em>Sugerencia Formativa:</em> Continúa utilizando este enfoque claro y directo para la liberación de recursos.
      </td>
    </tr>
    <tr>
      <td>poly_sumar</td>
      <td>1.0 / 2</td>
      <td>
        <strong>Funcionalidad:</strong> La función crea un nuevo polinomio y agrega los monomios de ambos operandos; sin embargo, dado que depende de <code>poly_agregar</code>, los problemas de inserción (especialmente al combinar términos iguales) se heredan, lo que puede dar lugar a resultados incorrectos en algunos casos.<br>
        <strong>Mantenimiento:</strong> La estrategia de sumar monomios de ambos polinomios de forma secuencial es razonable, pero se podría optimizar la combinación de términos concurrentemente para evitar dos recorridos completos.<br>
        <strong>Claridad:</strong> El código es legible, pero se beneficiaría de la verificación de parámetros (por ejemplo, si alguno de los polinomios es NULL) de manera más explícita.<br>
        <strong>Eficiencia:</strong> Se recorre cada lista de forma independiente, lo que resulta en un costo adicional cuando ambos tienen muchos elementos, pudiendo optimizarse la fusión simultánea.<br>
        <em>Sugerencia Formativa:</em> Revisa la función <code>poly_agregar</code> para corregir el problema de inserción y evalúa la posibilidad de fusionar las listas de monomios en una sola pasada para mejorar la eficiencia.
      </td>
    </tr>
  </table>
</body>
</html>