compila correctamente<br>
<html>
  <body>
    <p>Calificación final: 7/10<br></p>
    <table border="1">
      <tr>
        <th>Método</th>
        <th>Puntuación</th>
        <th>Retroalimentación</th>
      </tr>
      <tr>
        <td>poly_crear</td>
        <td>0.5 / 1</td>
        <td>
          <strong>Funcionalidad:</strong> La función reserva e inicializa la estructura correctamente, pero se requiere que en caso de fallo se finalice con código -1; se usa exit(1) en lugar de exit(-1).<br>
          <strong>Mantenimiento:</strong> El código es corto y directo, sin duplicación, pero se podría enriquecer con un mensaje de error más claro y consistente.<br>
          <strong>Claridad:</strong> Los nombres usados son descriptivos; sin embargo, se recomienda renombrar el parámetro a algo más intuitivo (por ejemplo, "polinomio") para mayor comprensión.<br>
          <strong>Eficiencia:</strong> No presenta bucles o condiciones complejas; la implementación es eficiente para el propósito.<br>
          <em>Sugerencia Formativa:</em> Ajustar el código de salida a exit(-1) y mejorar el mensaje de error para lograr especificaciones exactas.
        </td>
      </tr>
      <tr>
        <td>poly_grado</td>
        <td>1 / 1</td>
        <td>
          <strong>Funcionalidad:</strong> Calcula el grado consultando el último monomio, devolviendo -1 si el polinomio es NULL o vacío.<br>
          <strong>Mantenimiento:</strong> El código es simple y permite futuras modificaciones sin complicaciones.<br>
          <strong>Claridad:</strong> La variable "res" es clara y la lógica es lineal. Se recomienda, si se repite la comprobación de polinomio no nulo en otros métodos, considerar una función auxiliar.<br>
          <strong>Eficiencia:</strong> La implementación es de O(1) y responde eficientemente al requerimiento.<br>
          <em>Sugerencia Formativa:</em> Aunque es correcto, modularizar verificaciones comunes podría facilitar el mantenimiento a futuro.
        </td>
      </tr>
      <tr>
        <td>poly_coeficiente</td>
        <td>1 / 1</td>
        <td>
          <strong>Funcionalidad:</strong> La función recorre los monomios hasta el exponente indicado y devuelve correctamente el coeficiente o 0 si no se encuentra; se verifica que el exponente sea no negativo.<br>
          <strong>Mantenimiento:</strong> El uso de un bucle simple y comprobaciones claras facilita la extensión del método.<br>
          <strong>Claridad:</strong> Los nombres de variables son descriptivos y la estructura del loop es comprensible.<br>
          <strong>Eficiencia:</strong> Se evita recorrer de más gracias a la condición en el while, aunque se asume que la lista está ordenada.<br>
          <em>Sugerencia Formativa:</em> Considera documentar de forma breve el supuesto de orden en la lista para aumentar la claridad.
        </td>
      </tr>
      <tr>
        <td>poly_agregar</td>
        <td>1.0 / 2.5</td>
        <td>
          <strong>Funcionalidad:</strong> La función intenta insertar o actualizar un monomio existente en la lista. Sin embargo, si se intenta actualizar el primer elemento (cuando no se entra al loop) se utiliza una variable "previo" no inicializada, lo que puede causar errores en la suma y eliminación del nodo. Además, se usa exit(1) en vez de exit(-1) en caso de fallo en malloc. <br>
          <strong>Mantenimiento:</strong> Aunque se ha extraído la suma en la función auxiliar "sumarMonomiosF", la complejidad de manejar punteros a punteros y la falta de separación de casos (inicio, medio y final) dificultan su mantenimiento.<br>
          <strong>Claridad:</strong> El uso de variables como "aux" y "previo" puede resultar confuso, especialmente cuando "previo" no está inicializado en el caso de inserción al inicio.<br>
          <strong>Eficiencia:</strong> El algoritmo es adecuado en términos de eficiencia, utilizando un solo recorrido para encontrar la posición de inserción.<br>
          <em>Sugerencia Formativa:</em> Revisa el manejo del caso en que la operación se realiza sobre el primer nodo; inicializa correctamente la variable "previo" o trata ese caso por separado. Además, cumple estrictamente con el protocolo de salida para fallos en la asignación de memoria.
        </td>
      </tr>
      <tr>
        <td>poly_imprimir</td>
        <td>1.25 / 1.25</td>
        <td>
          <strong>Funcionalidad:</strong> Imprime los monomios en un formato legible y maneja correctamente el caso en que el polinomio es NULL.<br>
          <strong>Mantenimiento:</strong> El método es breve y no contiene duplicación de código; la función auxiliar "imprimirMonomio" ayuda a mantener bien organizado el código.<br>
          <strong>Claridad:</strong> El código resulta fácil de leer y se entiende la intención de cada parte.<br>
          <strong>Eficiencia:</strong> Utiliza un bucle simple y es eficiente en su propósito.<br>
          <em>Sugerencia Formativa:</em> La implementación es correcta; se podría agregar un comentario adicional explicativo en la llamada final a printf para separar salidas.
        </td>
      </tr>
      <tr>
        <td>poly_destruir</td>
        <td>1.25 / 1.25</td>
        <td>
          <strong>Funcionalidad:</strong> Libera adecuadamente todos los nodos y reinicializa los punteros del polinomio, evitando fugas de memoria.<br>
          <strong>Mantenimiento:</strong> El uso de dos punteros para recorrer y liberar la lista permite que el código sea extendido y modificado fácilmente.<br>
          <strong>Claridad:</strong> Las variables "head" y "aux" permiten seguir la lógica de liberación de memoria sin dificultad.<br>
          <strong>Eficiencia:</strong> La estrategia de liberar nodos en un solo recorrido es eficiente.<br>
          <em>Sugerencia Formativa:</em> Considera agregar comentarios sobre la importancia de reinicializar los punteros para reutilizar la estructura.
        </td>
      </tr>
      <tr>
        <td>poly_sumar</td>
        <td>1.0 / 2</td>
        <td>
          <strong>Funcionalidad:</strong> La función suma dos polinomios creando una nueva estructura e insertando los monomios de cada uno mediante poly_agregar. Sin embargo, al depender de poly_agregar, hereda el problema con la actualización de monomios en el primer nodo, lo que puede afectar la correcta suma cuando existen monomios con el mismo exponente.<br>
          <strong>Mantenimiento:</strong> La estrategia de sumar dos listas por separado es comprensible, pero integrar la suma de monomios coincidentes en un solo recorrido podría simplificar la lógica y el mantenimiento.<br>
          <strong>Claridad:</strong> El uso de ciclos separados para cada polinomio es claro, pero se recomienda verificar la validez de los punteros de entrada de forma independiente para mayor robustez.<br>
          <strong>Eficiencia:</strong> El método resulta en dos recorridos completos, lo cual es aceptable, aunque se podría optimizar fusionando ambos recorridos cuando las listas estén ordenadas.<br>
          <em>Sugerencia Formativa:</em> Asegúrate de manejar correctamente los casos extremos y considera refactorizar para evitar duplicación de código y aprovechar la ordenación inherente de los polinomios.
        </td>
      </tr>
    </table>
  </body>
</html>