Identificador,Nombre completo,Estado,Calificación,Calificación máxima,La calificación puede ser cambiada,Visualización/<br>entrega,Última modificación (calificación),Comentarios de retroalimentación del profesor
Participante_19140,Senador Rebeca,Sin&nbsp;entrega,"5,00","10,00",Sí,-,-,"Compila correctamente. <br><br><html><br>  <body><br>    Calificación final: 3/10<br><br>    <table border=""1""><br>      <tr><br>        <th>Método</th><br>        <th>Puntuación</th><br>        <th>Feedback</th><br>      </tr><br>      <tr><br>        <td>insert(K key)</td><br>        <td>0/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método falla en múltiples aspectos. En primer lugar, cuando el árbol está vacío (root==null) se lanza una excepción en lugar de insertar el nodo, incumpliendo el comportamiento esperado. Además, la construcción de un nodo auxiliar a partir de la clave de la raíz y la posterior llamada a splay no tiene sentido y conduce a una lógica errónea. <br><br>          <strong>Claridad:</strong> Se utilizan variables innecesarias (por ejemplo, la variable ""pass"" se inicializa a null y luego se utiliza en un bucle sin posibilidad real de cambiar su valor) lo que complica la lectura del código. <br><br>          <strong>Mantenimiento:</strong> La estructura del código dificulta futuras modificaciones y la lógica de inserción se dispersa con bucles y llamadas sin un objetivo claro. <br><br>          <strong>Eficiencia:</strong> Se invoca splay sin una estrategia clara y se realizan operaciones sin propósito real. <br><br>          <strong>Sugerencia Formativa:</strong> Revisa la definición de la inserción en un árbol splay. Recuerda que al insertar en un árbol splay, si el árbol está vacío se debe asignar la raíz y, en caso contrario, debes splay sobre la clave de inserción para reestructurar el árbol antes de insertar el nuevo nodo.<br>        </td><br>      </tr><br>      <tr><br>        <td>search(K key)</td><br>        <td>0/1.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método no implementa correctamente la búsqueda. Se crea un nodo auxiliar utilizando la raíz en forma inadecuada y se utiliza el método copyOf(this), el cual lanza una excepción de operación no implementada, haciendo que el método falle en tiempo de ejecución. Además, la comparación de claves se realiza mediante ""=="" en lugar de utilizar el comparador o el método equals, lo que puede dar falsos negativos. <br><br>          <strong>Claridad:</strong> Aunque los nombres de variables son aceptables, el flujo se complica al depender de una copia del árbol y del método splay en ella, lo que disminuye la legibilidad. <br><br>          <strong>Mantenimiento:</strong> La falta de implementación completa y la dependencia de métodos sin definir correctamente dificulta su mantenimiento. <br><br>          <strong>Eficiencia:</strong> Se realiza un flujo redundante al crear una copia del árbol solo para splayear el nodo, lo que es innecesario en una implementación correcta. <br><br>          <strong>Sugerencia Formativa:</strong> Asegúrate de definir bien el proceso de splay y evita depender de métodos no implementados. Utiliza la comparación de claves utilizando el comparador definido o .equals para garantizar la correcta búsqueda.<br>        </td><br>      </tr><br>      <tr><br>        <td>delete(K key)</td><br>        <td>0/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método no implementa la eliminación de un nodo, ya que se lanza directamente una excepción ""Implementa!"", lo que incumple la especificación del examen. <br><br>          <strong>Claridad:</strong> La intención del método es poco clara al no haber una estructura definida para la eliminación tras realizar el splay. <br><br>          <strong>Mantenimiento:</strong> Se dificulta el seguimiento y la extensión del código al dejar la parte principal sin implementar. <br><br>          <strong>Eficiencia:</strong> No se puede evaluar, ya que el método no contiene lógica funcional. <br><br>          <strong>Sugerencia Formativa:</strong> Implementa la eliminación aprovechando la operación splay: primero mueve el nodo a eliminar a la raíz y luego reestructura el árbol uniendo los subárboles según corresponda.<br>        </td><br>      </tr><br>      <tr><br>        <td>clear()</td><br>        <td>1/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> La implementación es correcta; se asigna null a la raíz y se pone el tamaño a cero. <br><br>          <strong>Claridad:</strong> El método es directo y fácil de entender. <br><br>          <strong>Mantenimiento:</strong> Su sencillez permite futuras modificaciones sin complicaciones. <br><br>          <strong>Eficiencia:</strong> Se ejecuta en tiempo constante, lo cual es adecuado para la funcionalidad requerida. <br><br>          <strong>Sugerencia Formativa:</strong> ¡Buen trabajo en este método!<br>        </td><br>      </tr><br>      <tr><br>        <td>deleteMinimum()</td><br>        <td>0/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método pretende eliminar el mínimo, pero en la implementación se crea un nodo auxiliar y se asigna la raíz a null sin una eliminación correcta de la mínima clave. Además, se llama a splay de forma inapropiada. <br><br>          <strong>Claridad:</strong> La lógica no es clara y se confunde al mezclar la eliminación del nodo mínimo con una operación de splay que no tiene efecto real en el árbol. <br><br>          <strong>Mantenimiento:</strong> La estructura dificulta la reutilización de código, ya que se ignoran métodos ya existentes como minimum() o delete(key). <br><br>          <strong>Eficiencia:</strong> Aunque se intenta usar splay, la implementación global no cumple su objetivo. <br><br>          <strong>Sugerencia Formativa:</strong> Revisa el método minimum() para localizar la clave más pequeña e integra ese resultado en una eliminación que preserve la estructura splay del árbol.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzigRight(Node&lt;K&gt; node)</td><br>        <td>1/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> La doble rotación a la derecha se realiza de forma correcta: se emplea una primera rotación y, si procede, se verifica la existencia de un hijo izquierdo para aplicar la segunda. <br><br>          <strong>Claridad:</strong> Aunque el método cumple su cometido, el uso de variables intermedias (como node2 y node3) podría simplificarse para mejorar la claridad. <br><br>          <strong>Mantenimiento:</strong> La estructura es relativamente sencilla, lo que facilita futuros ajustes. <br><br>          <strong>Eficiencia:</strong> La operación es O(1), siendo adecuada para el caso concreto. <br><br>          <strong>Sugerencia Formativa:</strong> Considera renombrar las variables con nombres que indiquen su rol en la rotación y añade comentarios explicativos para mejorar la comprensión.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzigLeft(Node&lt;K&gt; node)</td><br>        <td>1/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> La doble rotación a la izquierda está implementada correctamente siguiendo la lógica esperada. <br><br>          <strong>Claridad:</strong> El método es entendible, aunque se podría mejorar la descriptividad de los nombres de variables. <br><br>          <strong>Mantenimiento:</strong> La estructura modular y breve favorece la mantenibilidad. <br><br>          <strong>Eficiencia:</strong> La operación es rápida y de complejidad O(1). <br><br>          <strong>Sugerencia Formativa:</strong> Añade algunos comentarios para dejar claro el proceso de rotación y mejora ligeramente los nombres de las variables.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzagRightLeft(Node&lt;K&gt; node)</td><br>        <td>0/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> La implementación no gestiona correctamente la condición requerida: la primera rotación no debe realizarse si no existe el subárbol en la rama izquierda del hijo derecho. La lógica condicional falla y el método realiza rotaciones sin cumplir la especificación. <br><br>          <strong>Claridad:</strong> La estructura condicional y la reasignación de variables (por ejemplo, asignar node2=node) dificultan la comprensión del proceso de rotación. <br><br>          <strong>Mantenimiento:</strong> La complejidad innecesaria y la ausencia de comentarios explicativos hacen que el método sea propenso a errores y difícil de modificar. <br><br>          <strong>Eficiencia:</strong> Aunque la operación es O(1), la ineficacia en la lógica reduce su utilidad. <br><br>          <strong>Sugerencia Formativa:</strong> Revisa la lógica de las rotaciones en este caso particular. Separa claramente la condición para la primera rotación y asegúrate de que solo se aplica si existe el subárbol requerido.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzagLeftRight(Node&lt;K&gt; node)</td><br>        <td>0/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Este método, que debería realizar primero una rotación a la izquierda y luego a la derecha, no verifica correctamente que exista el subárbol en la rama derecha del hijo izquierdo. La ausencia de esta comprobación provoca que la operación no se aplique correctamente en todos los casos. <br><br>          <strong>Claridad:</strong> El uso de variables y la reasignación sin comentarios adecuados hacen difícil rastrear el comportamiento deseado. <br><br>          <strong>Mantenimiento:</strong> La estructura compleja y poco documentada incrementa el riesgo de errores en futuras modificaciones. <br><br>          <strong>Eficiencia:</strong> La inefficiencia es menor dada la complejidad O(1), pero la lógica defectuosa supone un fallo funcional. <br><br>          <strong>Sugerencia Formativa:</strong> Separa claramente las rotaciones y asegúrate de comprobar la existencia del subárbol requerido antes de realizar la primera rotación.<br>        </td><br>      </tr><br>      <tr><br>        <td>copyOf(SearchTree&lt;K&gt; that)</td><br>        <td>0/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método lanza una excepción sin implementar la copia de los datos, lo cual incumple el requerimiento de copiar los elementos del árbol. <br><br>          <strong>Claridad:</strong> La intención del método es comprensible, pero la falta de implementación impide evaluar su correcto funcionamiento. <br><br>          <strong>Mantenimiento:</strong> Al no estar implementado, resulta imposible valorar su estructura o facilidad de extensión. <br><br>          <strong>Eficiencia:</strong> No se puede evaluar dado que la implementación falta por completo. <br><br>          <strong>Sugerencia Formativa:</strong> Implementa una copia que recorra el árbol en orden (o preorden) de modo que se preserven, en la medida de lo posible, la estructura y los datos del árbol original.<br>        </td><br>      </tr><br>      <tr><br>        <td>copyOf(SplayTree&lt;K&gt; that)</td><br>        <td>0/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> Al igual que el otro método copyOf, este lanza una excepción sin realizar ninguna copia, incumpliendo el requisito de reproducir tanto los datos como la estructura del árbol. <br><br>          <strong>Claridad:</strong> La ausencia de implementación impide cualquier análisis de la claridad del código. <br><br>          <strong>Mantenimiento:</strong> Sin implementación, no es posible determinar la facilidad futura de mantenimiento. <br><br>          <strong>Eficiencia:</strong> No se evalúa por falta de lógica implementada. <br><br>          <strong>Sugerencia Formativa:</strong> Asegúrate de copiar no solo los datos, sino también la estructura exacta del árbol splay. Puedes aprovechar un recorrido en preorden para reconstruir el árbol de forma recursiva.<br>        </td><br>      </tr><br>    </table><br>  </body><br></html>"
Participante_19137,Zacarías Rusty,Sin&nbsp;entrega,"3,00","10,00",Sí,-,-,"Compila correctamente. <br><br><html><br>  <body><br>    <!-- Calificación final --><br>    8.15/10<br><br>    <table border=""1""><br>      <tr><br>        <th>Método</th><br>        <th>Puntuación</th><br>        <th>Feedback</th><br>      </tr><br>      <tr><br>        <td>insert(K key)</td><br>        <td>0.8/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se verifica correctamente que la clave no sea nula y se inserta o reemplaza el elemento de acuerdo con la especificación. Sin embargo, se usa una llamada recursiva híbrida (invocando splay en el helper y luego nuevamente en el método público) lo que genera sobrecoste innecesario.<br><br>          <strong>Mantenimiento:</strong> La estructura recursiva puede dificultar futuras modificaciones, ya que se realiza splay varias veces en distintos lugares.<br>we<br>          <strong>Claridad:</strong> El código es entendible pero se puede mejorar la legibilidad evitando la duplicación de llamadas a splay y organizando mejor el flujo de inserción.<br><br>          <strong>Eficiencia:</strong> Se incluyen llamadas duplicadas al método splay, lo cual no es óptimo.<br>        </td><br>      </tr><br>      <tr><br>        <td>search(K key)</td><br>        <td>1.5/1.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método busca la clave correctamente, lanzando la excepción en caso de un parámetro nulo o árbol vacío, y utiliza splay para reestructurar el árbol, cumpliendo los requisitos.<br><br>          <strong>Claridad:</strong> El flujo es claro y el uso de splay facilita la lectura del algoritmo.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La implementación hace buen uso de métodos auxiliares y no presenta sobrecostes adicionales.<br>        </td><br>      </tr><br>      <tr><br>        <td>delete(K key)</td><br>        <td>0.5/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Aunque se lanza la excepción para clave nula o árbol vacío y se realiza splay, si la clave no se encuentra se decrementa el tamaño del árbol erróneamente (se decrementa size aun cuando no se elimina ningún nodo).<br><br>          <strong>Claridad:</strong> La separación entre búsqueda (usando splay) y luego la eliminación en deleteRoot no queda suficientemente diferenciada, lo que dificulta la comprensión completa.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La estrategia de reestructuración es aceptable, pero se debe corregir la lógica para no alterar el size en casos no eliminados.<br>        </td><br>      </tr><br>      <tr><br>        <td>clear()</td><br>        <td>1/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método elimina correctamente todos los elementos del árbol, reiniciando la raíz y el tamaño.<br><br>          <strong>Claridad, Mantenimiento y Eficiencia:</strong> La implementación es sencilla, directa y fácil de mantener.<br>        </td><br>      </tr><br>      <tr><br>        <td>deleteMinimum()</td><br>        <td>0/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se splayea el árbol con el mínimo obtenido y se elimina al asignar root=root.right, pero no se actualiza el tamaño, lo que incumple la eliminación completa del mínimo.<br><br>          <strong>Claridad:</strong> El método podría beneficiarse de reutilizar el método minimum() de forma completa y gestionar la actualización del size.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La lógica es sencilla pero incompleta funcionalmente.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzigRight(Node&lt;K&gt; node)</td><br>        <td>0.9/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Realiza correctamente la doble rotación a la derecha, aplicando solo la segunda rotación si es necesario.<br><br>          <strong>Claridad:</strong> Aunque la implementación cumple, el uso de variables y la falta de comentarios explicativos pueden dificultar su comprensión.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> Es eficiente (O(1)) y su estructura es suficientemente modular para futuros cambios.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzigLeft(Node&lt;K&gt; node)</td><br>        <td>0.9/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se implementa correctamente la doble rotación a la izquierda.<br><br>          <strong>Claridad:</strong> Aunque cumple con lo requerido, se podría mejorar la legibilidad con nombres de variables más descriptivos y comentarios.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La solución es eficiente y fácil de modificar.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzagRightLeft(Node&lt;K&gt; node)</td><br>        <td>0.9/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método verifica la existencia del subárbol en la rama izquierda del hijo derecho y actúa en consecuencia, cumpliendo la especificación.<br><br>          <strong>Claridad:</strong> La falta de comentarios y una estructura mínima de explicación hacen que el proceso no sea del todo evidente al lector.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> Es eficiente (operación O(1)) pero se beneficiaría de una mayor claridad en el código.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzagLeftRight(Node&lt;K&gt; node)</td><br>        <td>0.9/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se realiza la doble rotación (primero a izquierda y luego a derecha) de forma que, si no existe el subárbol en la rama derecha del hijo izquierdo, se omite la primera rotación, cumpliendo lo pedido.<br><br>          <strong>Claridad:</strong> Al igual que en zigzagRightLeft, sería beneficioso incluir comentarios y nombres más descriptivos para mejorar su entendimiento.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La lógica es eficiente y modular, aunque puede perfeccionarse en cuanto a claridad.<br>        </td><br>      </tr><br>      <tr><br>        <td>copyOf(SearchTree&lt;K&gt; that)</td><br>        <td>0.5/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método copia correctamente los datos a partir de un recorrido inOrder, creando una nueva estructura que contiene los mismos elementos (aunque la estructura del árbol no se conserva, lo cual es acorde al requerimiento para este método).<br><br>          <strong>Claridad:</strong> El código es claro y se aprovecha el iterador del árbol.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> Es fácilmente mantenible y reutiliza el método insert; sin embargo, el proceso de reestructuración puede ser ineficiente para conjuntos muy grandes.<br>        </td><br>      </tr><br>      <tr><br>        <td>copyOf(SplayTree&lt;K&gt; that)</td><br>        <td>0.25/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se copia la estructura del árbol recursivamente usando el método auxiliar copyOf(Node). Sin embargo, se omite la actualización del tamaño (size) en el nuevo árbol, lo que no preserva completamente el estado del árbol original.<br><br>          <strong>Claridad:</strong> La estrategia recursiva es clara, pero faltan comentarios que expliquen la necesidad de copiar la estructura completa.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> Aunque la técnica es eficiente al copiar la estructura, la omisión del campo size puede generar inconsistencias en el futuro.<br>        </td><br>      </tr><br>    </table><br>  </body><br></html>"
Participante_19139,Estéban Amber,Sin&nbsp;entrega,,"10,00",Sí,-,-,
Participante_19138,Kappa Miguel,Sin&nbsp;entrega,,"10,00",Sí,-,-,
