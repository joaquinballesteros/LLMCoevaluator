Identificador,Nombre completo,Estado,Calificación,Calificación máxima,La calificación puede ser cambiada,Visualización/<br>entrega,Última modificación (calificación),Comentarios de retroalimentación del profesor
Participante_19140,Senador Rebeca,Sin&nbsp;entrega,"2,90","10,00",Sí,-,-,"<p>Compila correctamente. <br> 3/10<br></p>
<table border=""1"">
<tbody>
<tr>
<th>M&eacute;todo</th>
<th>Puntuaci&oacute;n</th>
<th>Retroalimentaci&oacute;n</th>
</tr>
<tr>
<td>insert(K key)</td>
<td>0/1</td>
<td><strong>Funcionalidad:</strong> La l&oacute;gica implementada para insertar un elemento es defectuosa. Se arroja una excepci&oacute;n si el &aacute;rbol est&aacute; vac&iacute;o en lugar de insertar el primer nodo, lo que impide que el &aacute;rbol acepte el primer elemento. Adem&aacute;s, la manipulaci&oacute;n del nodo mediante un bucle con variable 'pass' no se ejecuta porque la condici&oacute;n nunca se cumple.<br> <strong>Eficiencia:</strong> El uso de un bucle innecesario y la invocaci&oacute;n de splay sobre un nodo auxiliar generan complejidad extra sin aportar claridad.<br> <strong>Calidad del c&oacute;digo auxiliar:</strong> El m&eacute;todo se apoya en otros m&eacute;todos (splay, zigRight, zigLeft) pero la forma en que se invocan no respeta la sem&aacute;ntica requerida para la inserci&oacute;n en un &aacute;rbol Splay.<br> <strong>Claridad:</strong> La utilizaci&oacute;n de variables como 'aux' y 'pass' es confusa, y la intenci&oacute;n del bucle es dif&iacute;cil de seguir.<br> <strong>Buenas pr&aacute;cticas locales:</strong> Se deber&iacute;a controlar adecuadamente el caso de &aacute;rbol vac&iacute;o y evitar bucles cuya condici&oacute;n nunca se cumple.<br> <strong>Cobertura de casos l&iacute;mite y gesti&oacute;n de excepciones:</strong> El m&eacute;todo lanza excepciones apropiadas al recibir null, pero falla en cubrir el caso del &aacute;rbol vac&iacute;o para la inserci&oacute;n.</td>
</tr>
<tr>
<td>search(K key)</td>
<td>0/1.5</td>
<td><strong>Funcionalidad:</strong> La b&uacute;squeda falla debido a la creaci&oacute;n incorrecta de un nuevo nodo usando el nodo ra&iacute;z (se pasa un nodo en lugar de una clave) y a la dependencia del m&eacute;todo copyOf, que no est&aacute; implementado. Esto impide que se realice una b&uacute;squeda v&aacute;lida.<br> <strong>Eficiencia:</strong> La creaci&oacute;n de una copia completa del &aacute;rbol para prop&oacute;sitos de b&uacute;squeda es ineficiente.<br> <strong>Calidad del c&oacute;digo auxiliar:</strong> Se usa splay, pero la forma de invocarlo y la manipulaci&oacute;n del nodo son incorrectas.<br> <strong>Claridad:</strong> El c&oacute;digo es poco claro en cuanto al manejo del nodo auxiliar y la dependencia de copyOf sin implementaci&oacute;n.<br> <strong>Buenas pr&aacute;cticas locales:</strong> Se debe evitar depender de m&eacute;todos no implementados y manejar adecuadamente el &aacute;rbol vac&iacute;o.<br> <strong>Cobertura de casos l&iacute;mite y gesti&oacute;n de excepciones:</strong> Se verifica el par&aacute;metro null, pero no se gestiona el posible &aacute;rbol vac&iacute;o.</td>
</tr>
<tr>
<td>delete(K key)</td>
<td>0/1</td>
<td><strong>Funcionalidad:</strong> El m&eacute;todo no ha sido implementado y lanza una excepci&oacute;n de operaci&oacute;n no soportada.<br> <strong>Claridad:</strong> La intenci&oacute;n de implementar la eliminaci&oacute;n queda relegada a futuro, lo cual impide el correcto funcionamiento del &aacute;rbol.<br> <strong>Buenas pr&aacute;cticas locales:</strong> Se deber&iacute;a implementar una combinaci&oacute;n de splay y ajuste del &aacute;rbol para eliminar el nodo, en lugar de dejar un m&eacute;todo sin funcionalidad.</td>
</tr>
<tr>
<td>clear()</td>
<td>1/1</td>
<td><strong>Funcionalidad:</strong> Correcta, establece la ra&iacute;z a null y el tama&ntilde;o a cero, vaciando el &aacute;rbol.<br> <strong>Claridad:</strong> El c&oacute;digo es sencillo y directo.<br> <strong>Mantenimiento:</strong> F&aacute;cil de leer y mantener.</td>
</tr>
<tr>
<td>deleteMinimum()</td>
<td>0/0.5</td>
<td><strong>Funcionalidad:</strong> La eliminaci&oacute;n del m&iacute;nimo falla, ya que se crea un nodo auxiliar y se anula la ra&iacute;z sin buscar ni conservar el sub&aacute;rbol derecho o izquierdo de forma correcta. Tampoco se utiliza el m&eacute;todo minimum existente.<br> <strong>Claridad:</strong> La intenci&oacute;n de splay sobre aux.left es confusa y no se logra la eliminaci&oacute;n correcta.<br> <strong>Buenas pr&aacute;cticas locales:</strong> Se debe reutilizar el m&eacute;todo minimum para localizar el nodo y luego eliminarlo usando el m&eacute;todo delete.</td>
</tr>
<tr>
<td>zigzigRight(Node&lt;K&gt; node)</td>
<td>1/1</td>
<td><strong>Funcionalidad:</strong> Realiza la doble rotaci&oacute;n a la derecha seg&uacute;n lo solicitado, utilizando zigRight de forma consecutiva cuando procede.<br> <strong>Claridad:</strong> Aunque los nombres de variables pueden resultar un poco gen&eacute;ricos, la l&oacute;gica es comprensible.<br> <strong>Eficiencia:</strong> La operaci&oacute;n es de complejidad O(1), lo cual es adecuado.</td>
</tr>
<tr>
<td>zigzigLeft(Node&lt;K&gt; node)</td>
<td>1/1</td>
<td><strong>Funcionalidad:</strong> La doble rotaci&oacute;n a la izquierda se implementa correctamente.<br> <strong>Claridad:</strong> El proceso es claro pese a que se podr&iacute;an usar nombres de variables m&aacute;s descriptivos.<br> <strong>Eficiencia:</strong> Ejecuta en tiempo constante, cumpliendo el requerimiento.</td>
</tr>
<tr>
<td>zigzagRightLeft(Node&lt;K&gt; node)</td>
<td>0/1</td>
<td><strong>Funcionalidad:</strong> La implementaci&oacute;n no maneja correctamente el requerimiento de no realizar la primera rotaci&oacute;n si no existe el sub&aacute;rbol en la rama izquierda del hijo derecho. La manipulaci&oacute;n de variables (asignar node2=node) y el posterior zigLeft se realizan de forma incorrecta.<br> <strong>Claridad:</strong> La l&oacute;gica es confusa por el reuso inapropiado de las variables, lo que dificulta su comprensi&oacute;n.<br> <strong>Buenas pr&aacute;cticas locales:</strong> Se recomienda reestructurar la l&oacute;gica en m&eacute;todos privados auxiliares para separar y clarificar las condiciones.</td>
</tr>
<tr>
<td>zigzagLeftRight(Node&lt;K&gt; node)</td>
<td>0/1</td>
<td><strong>Funcionalidad:</strong> Similar al m&eacute;todo anterior, la doble rotaci&oacute;n izquierda-derecha no verifica correctamente la existencia del sub&aacute;rbol en la rama derecha del hijo izquierdo, lo que causa una aplicaci&oacute;n inadecuada de las rotaciones.<br> <strong>Claridad:</strong> El reuso de variables y la falta de comentarios explicativos hacen que el c&oacute;digo sea dif&iacute;cil de entender.<br> <strong>Buenas pr&aacute;cticas locales:</strong> Se aconseja dividir la l&oacute;gica en pasos y validar cada condici&oacute;n de manera independiente.</td>
</tr>
<tr>
<td>copyOf(SearchTree&lt;K&gt; that)</td>
<td>0/0.5</td>
<td><strong>Funcionalidad:</strong> El m&eacute;todo no se ha implementado, por lo que no cumple con el requisito de copiar los datos conservando la estructura.<br> <strong>Claridad:</strong> La firma del m&eacute;todo es correcta, pero la excepci&oacute;n lanzada indica que falta la implementaci&oacute;n.<br> <strong>Buenas pr&aacute;cticas locales:</strong> Es importante implementar la copia de estructura para cumplir con los requerimientos funcionales.</td>
</tr>
<tr>
<td>copyOf(SplayTree&lt;K&gt; that)</td>
<td>0/0.5</td>
<td><strong>Funcionalidad:</strong> Al igual que el m&eacute;todo anterior, este m&eacute;todo arroja una excepci&oacute;n en lugar de realizar la copia preservando la estructura.<br> <strong>Claridad:</strong> Aunque la intenci&oacute;n es clara, la falta de implementaci&oacute;n penaliza el cumplimiento de los requisitos.<br> <strong>Buenas pr&aacute;cticas locales:</strong> Se deber&iacute;a implementar la copia completa y fiel de la estructura del &aacute;rbol.</td>
</tr>
</tbody>
</table>"
Participante_19137,Zacarías Rusty,Sin&nbsp;entrega,"3,00","10,00",Sí,-,-,"Compila correctamente. <br><br><html><br>  <body><br>    <!-- Calificación final --><br>    8.15/10<br><br>    <table border=""1""><br>      <tr><br>        <th>Método</th><br>        <th>Puntuación</th><br>        <th>Feedback</th><br>      </tr><br>      <tr><br>        <td>insert(K key)</td><br>        <td>0.8/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se verifica correctamente que la clave no sea nula y se inserta o reemplaza el elemento de acuerdo con la especificación. Sin embargo, se usa una llamada recursiva híbrida (invocando splay en el helper y luego nuevamente en el método público) lo que genera sobrecoste innecesario.<br><br>          <strong>Mantenimiento:</strong> La estructura recursiva puede dificultar futuras modificaciones, ya que se realiza splay varias veces en distintos lugares.<br>we<br>          <strong>Claridad:</strong> El código es entendible pero se puede mejorar la legibilidad evitando la duplicación de llamadas a splay y organizando mejor el flujo de inserción.<br><br>          <strong>Eficiencia:</strong> Se incluyen llamadas duplicadas al método splay, lo cual no es óptimo.<br>        </td><br>      </tr><br>      <tr><br>        <td>search(K key)</td><br>        <td>1.5/1.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método busca la clave correctamente, lanzando la excepción en caso de un parámetro nulo o árbol vacío, y utiliza splay para reestructurar el árbol, cumpliendo los requisitos.<br><br>          <strong>Claridad:</strong> El flujo es claro y el uso de splay facilita la lectura del algoritmo.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La implementación hace buen uso de métodos auxiliares y no presenta sobrecostes adicionales.<br>        </td><br>      </tr><br>      <tr><br>        <td>delete(K key)</td><br>        <td>0.5/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Aunque se lanza la excepción para clave nula o árbol vacío y se realiza splay, si la clave no se encuentra se decrementa el tamaño del árbol erróneamente (se decrementa size aun cuando no se elimina ningún nodo).<br><br>          <strong>Claridad:</strong> La separación entre búsqueda (usando splay) y luego la eliminación en deleteRoot no queda suficientemente diferenciada, lo que dificulta la comprensión completa.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La estrategia de reestructuración es aceptable, pero se debe corregir la lógica para no alterar el size en casos no eliminados.<br>        </td><br>      </tr><br>      <tr><br>        <td>clear()</td><br>        <td>1/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método elimina correctamente todos los elementos del árbol, reiniciando la raíz y el tamaño.<br><br>          <strong>Claridad, Mantenimiento y Eficiencia:</strong> La implementación es sencilla, directa y fácil de mantener.<br>        </td><br>      </tr><br>      <tr><br>        <td>deleteMinimum()</td><br>        <td>0/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se splayea el árbol con el mínimo obtenido y se elimina al asignar root=root.right, pero no se actualiza el tamaño, lo que incumple la eliminación completa del mínimo.<br><br>          <strong>Claridad:</strong> El método podría beneficiarse de reutilizar el método minimum() de forma completa y gestionar la actualización del size.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La lógica es sencilla pero incompleta funcionalmente.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzigRight(Node&lt;K&gt; node)</td><br>        <td>0.9/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Realiza correctamente la doble rotación a la derecha, aplicando solo la segunda rotación si es necesario.<br><br>          <strong>Claridad:</strong> Aunque la implementación cumple, el uso de variables y la falta de comentarios explicativos pueden dificultar su comprensión.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> Es eficiente (O(1)) y su estructura es suficientemente modular para futuros cambios.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzigLeft(Node&lt;K&gt; node)</td><br>        <td>0.9/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se implementa correctamente la doble rotación a la izquierda.<br><br>          <strong>Claridad:</strong> Aunque cumple con lo requerido, se podría mejorar la legibilidad con nombres de variables más descriptivos y comentarios.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La solución es eficiente y fácil de modificar.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzagRightLeft(Node&lt;K&gt; node)</td><br>        <td>0.9/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método verifica la existencia del subárbol en la rama izquierda del hijo derecho y actúa en consecuencia, cumpliendo la especificación.<br><br>          <strong>Claridad:</strong> La falta de comentarios y una estructura mínima de explicación hacen que el proceso no sea del todo evidente al lector.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> Es eficiente (operación O(1)) pero se beneficiaría de una mayor claridad en el código.<br>        </td><br>      </tr><br>      <tr><br>        <td>zigzagLeftRight(Node&lt;K&gt; node)</td><br>        <td>0.9/1</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se realiza la doble rotación (primero a izquierda y luego a derecha) de forma que, si no existe el subárbol en la rama derecha del hijo izquierdo, se omite la primera rotación, cumpliendo lo pedido.<br><br>          <strong>Claridad:</strong> Al igual que en zigzagRightLeft, sería beneficioso incluir comentarios y nombres más descriptivos para mejorar su entendimiento.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> La lógica es eficiente y modular, aunque puede perfeccionarse en cuanto a claridad.<br>        </td><br>      </tr><br>      <tr><br>        <td>copyOf(SearchTree&lt;K&gt; that)</td><br>        <td>0.5/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> El método copia correctamente los datos a partir de un recorrido inOrder, creando una nueva estructura que contiene los mismos elementos (aunque la estructura del árbol no se conserva, lo cual es acorde al requerimiento para este método).<br><br>          <strong>Claridad:</strong> El código es claro y se aprovecha el iterador del árbol.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> Es fácilmente mantenible y reutiliza el método insert; sin embargo, el proceso de reestructuración puede ser ineficiente para conjuntos muy grandes.<br>        </td><br>      </tr><br>      <tr><br>        <td>copyOf(SplayTree&lt;K&gt; that)</td><br>        <td>0.25/0.5</td><br>        <td><br>          <strong>Funcionalidad:</strong> Se copia la estructura del árbol recursivamente usando el método auxiliar copyOf(Node). Sin embargo, se omite la actualización del tamaño (size) en el nuevo árbol, lo que no preserva completamente el estado del árbol original.<br><br>          <strong>Claridad:</strong> La estrategia recursiva es clara, pero faltan comentarios que expliquen la necesidad de copiar la estructura completa.<br><br>          <strong>Mantenimiento y Eficiencia:</strong> Aunque la técnica es eficiente al copiar la estructura, la omisión del campo size puede generar inconsistencias en el futuro.<br>        </td><br>      </tr><br>    </table><br>  </body><br></html>"
Participante_19139,Estéban Amber,Sin&nbsp;entrega,,"10,00",Sí,-,-,
Participante_19138,Kappa Miguel,Sin&nbsp;entrega,,"10,00",Sí,-,-,
